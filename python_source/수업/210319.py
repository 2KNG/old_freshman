'''
Python 이론

10진정수(0,1,2,3,4,5,6,7,8,9) 
2진수(0,1) -2개 
8진수(0,1,2,4,5,6,7)-8개
16진수(0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f)-16개
보수(음수) : 1의 보수, 2의 보수 3을 
9-3=6(뺄셈), 9+(-3) 컴퓨터는 뺄셈을 못해서 덧셈으로 바꿔줘야함
8진법을 2진법 숫자를 3개씩 묶어서 계산하면 개꿀 111111 = 77 = 63
똑같이 16진법을 2진법 숫자 4개씩 묶어서 계산해도 개꿀
0b011100001(2) = e1(16)
0b001101111(2) = 6f(16)
0b < 2진법
0o < 8진법 
0x < 16진법
반대로
"%o" % > 8진법
"%x" % > 16진법
"%d" % > 10진법
'''

# print(0b11100001) #225
# print(0b01101111) #111
# print(0xf4) #244
# print(0o63) #51
# print("%o"%123)
# print("%x"%123)
# from random import *
# print(randint(1,45))

'''
보수
2진법의 3가지 음수표현
부호와 절대치 X 000001 양수 1이라는 뜻, 100001 음수 1이라는 뜻
1의 보수법 사용 X 000101 양수 5 > 1의 보수법 > 111010  
2의 보수법 사용 O 000101 양수 5 > 2의 보수법 > 111010 + 1 > 111011
>>2의 보수법이란, 1의 보수법에서 +1을 한 값
뒤에서부터 1나올때까지 따라하다가 1이나오면 거기까지 적고 반전값
101100 > 010100
보수란 음수표현이다. 절대 +,- 가 아니다 ^^ㅣ발^^ㅣ발^^ㅣ발^^ㅣ발
~ 는 1의 보수값
~n+1 은 2 의 보수값
'''

print("%d" %5)
print(~5)
print(~5+1)
print(~-3+1)

'''
8자리 까는게 국룰
 5   =   00000101     5-2=       00000101
-2   = -)00000010 = (2의보수법) +)11111110
 3                               00000010
 2                               00000010
-5     -)00000101                11111011
-3     -)00000011                11111101
'''

print(~5)
print(~-230+1)